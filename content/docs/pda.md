---
title: "Pushdown Automaton (PDA)"
description: "Theory and usage guide for Pushdown Automata in StateForge"
---

# Pushdown Automaton (PDA)

A **Pushdown Automaton** extends finite automata with a stack ‚Äî an unlimited memory structure that lets it recognize languages no DFA or NFA can handle. If you've ever matched nested parentheses or parsed a programming language, you've encountered problems that need a PDA.

![PDA simulation](/docs/pda-sim.png)

---

## Theory

### Formal definition

A PDA is defined as a **7-tuple** (Q, Œ£, Œì, Œ¥, q‚ÇÄ, Z‚ÇÄ, F):

| Symbol | Meaning |
|--------|---------|
| **Q** | Finite set of states |
| **Œ£** | Input alphabet |
| **Œì** | Stack alphabet |
| **Œ¥** | Transition function: Q √ó (Œ£ ‚à™ {Œµ}) √ó (Œì ‚à™ {Œµ}) ‚Üí ùí´(Q √ó Œì*) |
| **q‚ÇÄ** | Start state (q‚ÇÄ ‚àà Q) |
| **Z‚ÇÄ** | Initial stack symbol (Z‚ÇÄ ‚àà Œì) |
| **F** | Set of accepting/final states (F ‚äÜ Q) |

The key difference from finite automata is **Œì** (the stack alphabet) and **Z‚ÇÄ** (the initial stack symbol). These give the PDA memory that grows and shrinks as needed.

### The stack

The stack is a **LIFO** (Last In, First Out) data structure. Think of it as a spring-loaded plate dispenser ‚Äî you can only see and remove the top plate, and new plates go on top.

- **Push**: Place a symbol on top of the stack
- **Pop**: Remove the top symbol from the stack
- **Peek**: Read the top symbol without removing it

This stack gives PDAs "memory" that finite automata lack. A DFA has no way to count ‚Äî it can't remember how many `a`'s it's seen to match them with `b`'s. A PDA can push a symbol for each `a`, then pop one for each `b`, accepting only when the counts match.

### Transition function

Each PDA transition reads three things and produces two:

```
Œ¥(current_state, input_symbol, stack_top) ‚Üí (new_state, symbols_to_push)
```

- **input_symbol** can be Œµ (don't consume any input ‚Äî an epsilon transition)
- **stack_top** can be Œµ (don't require any particular stack top)
- **symbols_to_push** can be Œµ (push nothing ‚Äî effectively just popping)

For example, Œ¥(q‚ÇÄ, a, Z) ‚Üí (q‚ÇÄ, AZ) means: "In state q‚ÇÄ, reading `a` from input, with `Z` on top of the stack, move to state q‚ÇÄ, pop `Z`, and push `AZ`." The net effect is pushing `A` on top of `Z`.

### Acceptance modes

There are two ways a PDA can accept a string:

**By final state:** The PDA accepts if, after consuming all input, it is in a state from F (an accepting state). The stack contents don't matter.

**By empty stack:** The PDA accepts if, after consuming all input, the stack is completely empty. The current state doesn't matter.

These two modes are **equivalent in power** ‚Äî for any PDA accepting by final state, there exists a PDA accepting by empty stack for the same language, and vice versa. The constructions are straightforward but the resulting PDAs may look quite different.

### Context-free languages

PDAs recognize exactly the class of **context-free languages (CFLs)**. This is the same class of languages generated by context-free grammars (CFGs). The equivalence is fundamental:

- **Every CFG has an equivalent PDA.** Given a grammar, you can mechanically construct a PDA that simulates leftmost derivations.
- **Every PDA has an equivalent CFG.** Given a PDA, you can (less intuitively) construct a grammar that generates the same language.

This means PDAs sit squarely between finite automata and Turing machines in the Chomsky hierarchy:

```
Regular Languages ‚äÇ Context-Free Languages ‚äÇ Context-Sensitive Languages ‚äÇ Recursively Enumerable
   (DFA/NFA)              (PDA/CFG)                                           (Turing Machine)
```

### Nondeterminism matters

Unlike finite automata (where DFA = NFA in power), **nondeterministic PDAs are strictly more powerful than deterministic PDAs (DPDAs)**.

- A **DPDA** has at most one move in any configuration ‚Äî no choices. DPDAs recognize a proper subset of CFLs called deterministic context-free languages (used in most programming language parsers).
- A **nondeterministic PDA** (NPDA) can have multiple possible transitions from the same configuration. It accepts if *any* computation path leads to acceptance.

The classic example: the language of **even-length palindromes** {ww·¥ø | w ‚àà {a,b}*} requires nondeterminism ‚Äî the PDA must "guess" the middle of the string. No DPDA can recognize this language.

StateForge simulates the full nondeterministic PDA, exploring all possible computation paths simultaneously.

### Classic examples

| Language | Description | Key Insight |
|----------|-------------|-------------|
| {a‚Åøb‚Åø \| n ‚â• 0} | Equal a's and b's | Push on `a`, pop on `b` |
| Balanced parentheses | Nested ( and ) | Push on `(`, pop on `)` |
| {ww·¥ø} | Even palindromes | Push first half, match second half (nondeterministic) |
| {wcw·¥ø} | Palindromes with center | Push until `c`, then match (deterministic) |

### Limitations

PDAs cannot recognize everything. The language {a‚Åøb‚Åøc‚Åø | n ‚â• 0} (equal numbers of a's, b's, *and* c's) is **not context-free** ‚Äî a single stack can't simultaneously track two independent counts. This language is context-sensitive, requiring a more powerful model (like a linear bounded automaton or Turing machine).

Other non-CFL examples: {a‚Åø | n is prime}, {a‚Åø¬≤ | n ‚â• 0}, and the copy language {ww | w ‚àà {a,b}*} (note: **ww**, not **ww·¥ø**).

---

## Using PDA in StateForge

### Switching to PDA mode

Press **`3`** on your keyboard or select **PDA** from the mode dropdown in the sidebar. The editor switches to PDA mode with:

- Transition labels in `input, pop ‚Üí push` format
- Stack visualization in the simulation panel
- Acceptance mode toggle (Final State / Empty Stack)

### Transition format

PDA transitions in StateForge use the format:

```
input, pop ‚Üí push
```

| Part | Meaning | Example |
|------|---------|---------|
| **input** | Symbol to read from input (or Œµ to read nothing) | `a`, `b`, `Œµ` |
| **pop** | Symbol expected on top of stack (or Œµ for no requirement) | `Z`, `A`, `Œµ` |
| **push** | Symbols to push onto stack (or Œµ to push nothing) | `AZ`, `A`, `Œµ` |

**Examples:**

- `a, Z ‚Üí AZ` ‚Äî Read `a`, pop `Z`, push `AZ` (net: push `A` on top of existing `Z`)
- `b, A ‚Üí Œµ` ‚Äî Read `b`, pop `A`, push nothing (net: just pop `A`)
- `Œµ, Z ‚Üí Œµ` ‚Äî Read nothing, pop `Z`, push nothing (used for empty-stack acceptance)
- `Œµ, Œµ ‚Üí S` ‚Äî Read nothing, require nothing on stack, push `S`

### Stack symbol conventions

- **Z** ‚Äî The initial bottom-of-stack marker. Every PDA in StateForge starts with `Z` on the stack. It's a sentinel ‚Äî when you see `Z` on top, the stack is logically empty.
- **Œµ** ‚Äî Represents "nothing." As pop: don't check the stack. As push: don't push anything. As input: don't consume any character.

### Push convention

When pushing multiple characters, the **leftmost character ends up on top** of the stack.

For `push = AZ`:
1. `Z` is pushed first (goes deeper)
2. `A` is pushed second (becomes the new top)

So after `a, Z ‚Üí AZ`, the stack reads `A` on top, `Z` below ‚Äî identical to the original stack with `A` added on top.

Internally, the push string is reversed and each character is pushed individually, so `AZ` means the top-of-stack (TOS) is `A`.

### Multiple transitions

Unlike DFA (where each state has exactly one transition per symbol), PDA allows **multiple transitions between the same pair of states** ‚Äî and even multiple transitions from the same state on the same input. This is where nondeterminism comes from.

Each transition edge can carry multiple PDA transition entries. Click a transition to edit, and add as many `input, pop ‚Üí push` rules as needed.

### Simulation

The PDA simulator explores **all possible computation paths** simultaneously. Each path is tracked as a **configuration**: a triple of (current state, input position, stack contents).

**Controls:**

| Button | Action |
|--------|--------|
| **‚ñ∂ Start** | Initialize simulation with input string |
| **‚è≠ Step** | Advance all active configurations by one step |
| **‚è© Fast Run** | Run up to 500 steps automatically |
| **‚Ü∫ Reset** | Clear simulation state |

**What you see during simulation:**

- **Active Configs** ‚Äî Each row shows: state name, input position, and current stack contents in `[brackets]`
- **Input Tape** ‚Äî Visual tape with highlighting for consumed/current positions
- **Stack Visualization** ‚Äî A vertical stack display (desktop only) showing the top configuration's stack, with the top-of-stack highlighted

As you step through, configurations **branch** when nondeterministic choices exist (e.g., a state has both an Œµ-transition and an input-consuming transition). Dead-end branches are pruned as rejected.

### Acceptance toggle

In the simulation panel header, toggle between:

- **Final State** ‚Äî Accepts when all input is consumed AND the PDA is in an accepting state (double circle)
- **Empty Stack** ‚Äî Accepts when all input is consumed AND the stack is completely empty

Choose the mode that matches your PDA's design. Some PDAs are naturally designed for one mode over the other.

### Safety limits

Nondeterministic PDAs can produce an exponential number of configurations ‚Äî especially with Œµ-transitions that loop. StateForge enforces a **10,000 configuration limit**. If the total number of configurations created during simulation exceeds this, the simulation halts to prevent your browser from freezing.

If you hit this limit:
- Check for Œµ-transition loops (Œµ-transitions that cycle without consuming input or changing the stack)
- Simplify the PDA or test with shorter input strings

### Fast run

**Fast Run** executes up to **500 steps** in one click, giving you instant accept/reject results without stepping manually. Ideal for testing your PDA against multiple inputs quickly.

### Gallery examples

StateForge includes pre-built PDA examples in the gallery:

| Example | Language | Description |
|---------|----------|-------------|
| **a‚Åøb‚Åø** | {a‚Åøb‚Åø \| n ‚â• 0} | The classic PDA example ‚Äî push for a's, pop for b's |
| **Balanced Parentheses** | Matched ( and ) with nesting | Push on open, pop on close |
| **Palindromes** | {ww·¥ø \| w ‚àà {a,b}*} | Nondeterministic ‚Äî must guess the middle |
| **wcw·¥ø** | {wcw·¥ø \| w ‚àà {a,b}*} | Deterministic ‚Äî center marker `c` eliminates guessing |

Load these from the sidebar gallery to study how they work, then modify them or build your own.

---

## Tips

- **Always use Z as your bottom marker.** StateForge initializes every PDA stack with `Z`. Design your transitions around it ‚Äî checking for `Z` tells you when the stack is "logically empty," which is essential for clean acceptance conditions.

- **Push Œµ to pop without pushing.** The transition `b, A ‚Üí Œµ` pops `A` and pushes nothing. This is how you consume stack symbols during the matching phase (e.g., popping one `A` for each `b` in the a‚Åøb‚Åø language).

- **Multiple active configurations = nondeterminism in action.** If you see more than one active config during simulation, your PDA is exploring multiple branches. This is normal and expected ‚Äî remember, a nondeterministic PDA accepts if *any* branch accepts.

- **Test with empty string.** Don't forget edge cases! The empty string (Œµ) should be accepted by {a‚Åøb‚Åø} (when n=0) but rejected by many other languages.

- **Beware Œµ-loops.** An Œµ-transition that doesn't change the stack or state creates an infinite loop. The 10,000-config safety limit will catch this, but it's better to design your PDA to avoid it.

- **Start simple.** Build the a‚Åøb‚Åø PDA first ‚Äî it's the "hello world" of pushdown automata. Once that clicks, palindromes and more complex languages follow naturally.
